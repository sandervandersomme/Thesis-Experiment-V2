import torch
import torch.nn as nn
import numpy as np
from GAN import Generator, Discriminator
from utils import generate_noise

class TimeGAN():
    """
    Time-series GAN consisting of a generator, discriminator, embedder and recovery function.
    """
    
    __MODEL__ = "TimeGAN"

    def __init__(self, data: torch.Tensor, device, input_dim: int, hidden_dim: int, latent_dim: int, batch_size: int, seed: int = None):
        self.device = device
        self.data = data

        # set seed for reproducibility
        if seed:
            torch.manual_seed(seed)

        # set parameters
        _, self.seq_length, self.num_of_features = self.data.shape
        self.hidden_dim = hidden_dim
        self.input_dim = input_dim
        self.batch_size = batch_size

        # Create architecture
        self.generator = Generator(self.input_dim, self.hidden_dim, self.num_of_features)
        self.discriminator = Discriminator(self.num_of_features, self.hidden_dim)
        self.supervisor = Supervisor(latent_dim, hidden_dim, self.num_of_features)
        self.embedder = Embedder(input_dim, hidden_dim, latent_dim)
        self.recovery = Recovery(latent_dim, hidden_dim, self.num_of_features)

    def generate_data(self, num_samples, data_path):
        noise = generate_noise(num_samples, self.seq_length, self.num_of_features)
        with torch.no_grad():
            generated_data = self.generator(noise)
            np.save("data/output/"+ data_path + "_" + self.__MODEL__, generated_data.numpy())
            return generated_data

class Embedder(nn.Module):
    """
    A GRU based embedder that takes in real sequences and converts it into a latent representation
    """

    def __init__(self, input_dim, hidden_dim, output_dim):
        super(Embedder, self).__init__()

        self.rnn = nn.GRU(input_dim, hidden_dim, batch_first=True)
        self.output_layer = nn.Sequential(nn.Linear(hidden_dim, output_dim), nn.Sigmoid())

    def forward(self, real_sequences):
        output, _ = self.rnn(real_sequences)
        return self.output_layer(output)

class Recovery(nn.Module):
    """
    A GRU based recovery network that takes in a latent representation and returns a reconstructed sample
    """

    def __init__(self, input_dim, hidden_dim, output_dim):
        super(Recovery, self).__init__()

        self.rnn = nn.GRU(input_dim, hidden_dim, batch_first=True)
        self.output_layer = nn.Sequential(nn.Linear(hidden_dim, output_dim), nn.Sigmoid())

    def forward(self, latent_vector):
        rnn_output, _ = self.rnn(latent_vector)
        return self.output_layer(rnn_output)

class Supervisor(nn.Module):
    """
    A GRU based supervisor that takes in latent representations generated by the generator and returns the sequence generated from the latent representation
    """

    def __init__(self, input_dim, hidden_dim, output_dim):
        super(Supervisor, self).__init__()

        self.rnn = nn.GRU(input_dim, hidden_dim, batch_first=True)
        self.output_layer = nn.Sequential(nn.Linear(hidden_dim, output_dim), nn.Sigmoid())

    def forward(self, latent_representations):
        output, _ = self.rnn(latent_representations)
        return self.output_layer(output)